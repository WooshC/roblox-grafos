--[[
	MINIMAPA INTEGRADO v1 - Dentro de GUIExplorador
	‚úÖ Mantiene toda la funcionalidad del minimapa original
	‚úÖ Funciona en el ContenedorMiniMapa de GUIExplorador
	‚úÖ Usa ViewportFrame + WorldModel
]]

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local LevelsConfig = require(ReplicatedStorage:WaitForChild("LevelsConfig"))

print("üó∫Ô∏è [MinimapIntegrado] Iniciando sistema de minimapa integrado...")

-- ================================================================
-- OBTENER LA GUI EXPLORADOR
-- ================================================================

local gui = playerGui:WaitForChild("GUIExplorador", 10)
if not gui then
	warn("‚ùå [MinimapIntegrado] GUIExplorador no encontrada")
	return
end

print("‚úÖ [MinimapIntegrado] GUIExplorador encontrada")

-- ================================================================
-- OBTENER CONTENEDOR DEL MINIMAPA
-- ================================================================

local contenedorMiniMapa = gui:FindFirstChild("ContenedorMiniMapa")
if not contenedorMiniMapa then
	warn("‚ùå [MinimapIntegrado] ContenedorMiniMapa no encontrado")
	return
end

print("‚úÖ [MinimapIntegrado] ContenedorMiniMapa encontrado")

-- ================================================================
-- OBTENER O CREAR VISTA (ViewportFrame)
-- ================================================================

local vista = contenedorMiniMapa:FindFirstChild("Vista")

-- ================================================================
-- OBTENER O CREAR WORLDMODEL
-- ================================================================

local worldModel = vista:FindFirstChild("WorldModel")

if not worldModel then
	-- Create WorldModel if missing
	worldModel = Instance.new("WorldModel")
	worldModel.Name = "WorldModel"
	worldModel.Parent = vista
end

-- ================================================================
-- CREAR Y CONFIGURAR C√ÅMARA DEL VIEWPORT
-- ================================================================

local miniCamera = vista.CurrentCamera

if not miniCamera then
	-- Create Camera if missing
	miniCamera = Instance.new("Camera")
	miniCamera.FieldOfView = 70
	miniCamera.Parent = vista
	vista.CurrentCamera = miniCamera
end

-- ================================================================
-- CONFIGURACI√ìN
-- ================================================================

local ZOOM = 160
local TAMANO_MAPA = 250

-- Estado
local nivelActualID = nil
local nivelActualIDAnterior = -999
local carpetaPostesReal = nil
local mapaSelectores = {}
local listaCables = {}
local listaParticulas = {}
local cantidadCablesAnterior = 0
local updateConnection = nil

print("‚úÖ [MinimapIntegrado] Configuraci√≥n lista")

-- ================================================================
-- FUNCI√ìN: CARGAR SELECTORES
-- ================================================================

local function cargarSelectores(nivelID)
	-- Prevenir carga m√∫ltiple
	if nivelActualIDAnterior == nivelID and carpetaPostesReal then
		print("‚ö†Ô∏è [MinimapIntegrado] Nivel " .. nivelID .. " ya cargado")
		return
	end

	print("üó∫Ô∏è [MinimapIntegrado] Cargando selectores para nivel " .. nivelID)

	-- Limpiar worldModel
	worldModel:ClearAllChildren()
	mapaSelectores = {}
	listaCables = {}
	listaParticulas = {}

	local config = LevelsConfig[nivelID]
	if not config then
		warn("‚ö†Ô∏è [MinimapIntegrado] Config no existe para nivel " .. nivelID)
		return
	end

	-- Buscar modelo del nivel
	local nivelModel = Workspace:FindFirstChild("NivelActual")
	if not nivelModel then
		nivelModel = Workspace:FindFirstChild(config.Modelo)
	end
	if not nivelModel then
		nivelModel = Workspace:FindFirstChild("Nivel" .. nivelID)
	end

	if not nivelModel then
		warn("‚ö†Ô∏è [MinimapIntegrado] Modelo del nivel no encontrado")
		return
	end

	-- Buscar carpeta de postes
	carpetaPostesReal = nivelModel:FindFirstChild("Objetos") and nivelModel.Objetos:FindFirstChild("Postes")
	if not carpetaPostesReal then
		carpetaPostesReal = nivelModel:FindFirstChild("Postes", true)
	end

	if not carpetaPostesReal then
		warn("‚ö†Ô∏è [MinimapIntegrado] Carpeta Postes no encontrada")
		return
	end

	print("üì¶ [MinimapIntegrado] Carpeta encontrada: " .. carpetaPostesReal:GetFullName())

	-- Clonar selectores
	local cantidadClonados = 0
	for _, poste in pairs(carpetaPostesReal:GetChildren()) do
		if poste:IsA("Model") then
			local selectorReal = poste:FindFirstChild("Selector")
			if selectorReal and selectorReal:IsA("BasePart") then
				local selectorClon = selectorReal:Clone()
				selectorClon.Name = poste.Name .. "_Selector"
				selectorClon.CanCollide = false
				selectorClon.Anchored = true
				selectorClon.CastShadow = false

				-- Limpiar scripts
				for _, child in pairs(selectorClon:GetDescendants()) do
					if child:IsA("Script") or child:IsA("LocalScript") then
						child:Destroy()
					end
				end

				selectorClon.Parent = worldModel

				mapaSelectores[poste.Name] = {
					Real = selectorReal,
					Clon = selectorClon,
					Poste = poste
				}

				cantidadClonados = cantidadClonados + 1
			end
		end
	end

	print("‚úÖ [MinimapIntegrado] " .. cantidadClonados .. " selectores clonados")

	nivelActualIDAnterior = nivelID
end

-- ================================================================
-- FUNCI√ìN: SINCRONIZAR SELECTORES
-- ================================================================

local function sincronizarSelectores()
	if not carpetaPostesReal then return end

	for nombrePoste, refs in pairs(mapaSelectores) do
		local selectorReal = refs.Real
		local selectorClon = refs.Clon
		local posteReal = refs.Poste

		if selectorReal and selectorClon and posteReal then
			local energizado = posteReal:GetAttribute("Energizado")
			local nombre = posteReal.Name

			selectorClon.Transparency = 0
			selectorClon.Material = Enum.Material.Neon

			-- L√≥gica de color del selector real
			if selectorReal.Material == Enum.Material.Neon or selectorReal.Material == Enum.Material.Glass then
				selectorClon.Color = selectorReal.Color
				selectorClon.Material = Enum.Material.Neon
			else
				-- L√≥gica normal
				if nombre == "PostePanel" or nombre == "GeneradorCentral" then
					selectorClon.Color = Color3.fromRGB(52, 152, 219)
				elseif nombre == "PosteFinal" or nombre == "TorreControl" then
					selectorClon.Color = Color3.fromRGB(255, 140, 0)
				elseif energizado == true then
					selectorClon.Color = Color3.new(0, 1, 0) -- Verde
				else
					selectorClon.Color = Color3.fromRGB(231, 76, 60) -- Rojo
				end
			end
		end
	end
end

-- ================================================================
-- FUNCI√ìN: ACTUALIZAR CABLES
-- ================================================================

local function actualizarCables()
	-- Limpiar cables anteriores
	for _, cable in ipairs(listaCables) do
		if cable and cable.Parent then
			cable:Destroy()
		end
	end
	listaCables = {}

	if not carpetaPostesReal then return end

	-- Buscar carpeta de conexiones
	local carpetaConexiones = carpetaPostesReal:FindFirstChild("Conexiones")
	if not carpetaConexiones then
		carpetaConexiones = carpetaPostesReal.Parent:FindFirstChild("Conexiones")
	end

	if not carpetaConexiones then
		return
	end

	-- Helper para obtener clave del cable
	local function getCableKey(att0, att1)
		if not att0 or not att1 then return nil end
		local p0 = att0.Parent
		local p1 = att1.Parent
		if not p0 or not p1 then return nil end
		local m0 = p0:FindFirstAncestorWhichIsA("Model")
		local m1 = p1:FindFirstAncestorWhichIsA("Model")
		if m0 and m1 then
			return (m0.Name < m1.Name) and (m0.Name .. "_" .. m1.Name) or (m1.Name .. "_" .. m0.Name)
		end
		return nil
	end

	-- Mapear cables fantasma
	local mapaFantasmas = {}
	for _, obj in ipairs(workspace:GetChildren()) do
		if obj.Name == "CableFantasmaAlgoritmo" and obj:IsA("RopeConstraint") and obj.Visible then
			local key = getCableKey(obj.Attachment0, obj.Attachment1)
			if key then
				mapaFantasmas[key] = obj
			end
		end
	end

	-- Dibujar cables reales
	for _, cable in ipairs(carpetaConexiones:GetChildren()) do
		if cable:IsA("RopeConstraint") and cable.Visible then
			local attA = cable.Attachment0
			local attB = cable.Attachment1

			if attA and attB then
				local key = getCableKey(attA, attB)
				if key then
					local dist = (attA.WorldPosition - attB.WorldPosition).Magnitude
					local centro = (attA.WorldPosition + attB.WorldPosition) / 2

					local cablePart = Instance.new("Part")
					cablePart.Name = "CableVisualPart"
					cablePart.Anchored = true
					cablePart.CanCollide = false
					cablePart.CastShadow = false
					cablePart.Material = Enum.Material.Neon
					cablePart.Size = Vector3.new(2, 2, dist)
					cablePart.CFrame = CFrame.lookAt(centro, attB.WorldPosition)

					-- Decidir color
					if mapaFantasmas[key] then
						local fantasma = mapaFantasmas[key]
						cablePart.Color = fantasma.Color.Color
						cablePart.Material = Enum.Material.Neon
						mapaFantasmas[key] = nil
					else
						-- Color normal
						local pA = attA.Parent:FindFirstAncestorWhichIsA("Model")
						local pB = attB.Parent:FindFirstAncestorWhichIsA("Model")
						local eA = pA and pA:GetAttribute("Energizado")
						local eB = pB and pB:GetAttribute("Energizado")

						if eA and eB then
							cablePart.Color = Color3.new(0, 1, 0) -- Verde
						else
							cablePart.Color = Color3.fromRGB(80, 80, 80) -- Gris
						end
					end

					cablePart.Transparency = 0
					cablePart.Parent = worldModel
					table.insert(listaCables, cablePart)
				end
			end
		end
	end

	-- Dibujar fantasmas restantes
	for key, fantasma in pairs(mapaFantasmas) do
		local attA = fantasma.Attachment0
		local attB = fantasma.Attachment1
		if attA and attB then
			local dist = (attA.WorldPosition - attB.WorldPosition).Magnitude
			local centro = (attA.WorldPosition + attB.WorldPosition) / 2

			local cablePart = Instance.new("Part")
			cablePart.Name = "CableFantasmaVisual"
			cablePart.Anchored = true
			cablePart.CanCollide = false
			cablePart.CastShadow = false
			cablePart.Material = Enum.Material.Neon
			cablePart.Size = Vector3.new(2.5, 2.5, dist)
			cablePart.CFrame = CFrame.lookAt(centro, attB.WorldPosition)
			cablePart.Color = fantasma.Color.Color
			cablePart.Transparency = 0
			cablePart.Parent = worldModel
			table.insert(listaCables, cablePart)
		end
	end

	if #listaCables ~= cantidadCablesAnterior then
		print("üîå [MinimapIntegrado] Cables actualizados: " .. #listaCables)
		cantidadCablesAnterior = #listaCables
	end
end

-- ================================================================
-- LISTENER: CAMBIO DE NIVEL
-- ================================================================

player:GetAttributeChangedSignal("CurrentLevelID"):Connect(function()
	local levelID = player:GetAttribute("CurrentLevelID")

	print("üîî [MinimapIntegrado] CurrentLevelID cambi√≥ a: " .. tostring(levelID))

	if levelID and levelID >= 0 then
		if levelID ~= nivelActualIDAnterior then
			print("üó∫Ô∏è [MinimapIntegrado] Activando para nivel " .. levelID)
			nivelActualID = levelID

			cargarSelectores(levelID)
			actualizarCables()

			task.wait(0.5)
			contenedorMiniMapa.Visible = true
			print("‚úÖ [MinimapIntegrado] Minimapa habilitado")
		end
	else
		print("üó∫Ô∏è [MinimapIntegrado] Deshabilitando minimapa")
		contenedorMiniMapa.Visible = false
		nivelActualID = nil
		nivelActualIDAnterior = -999
		carpetaPostesReal = nil
	end
end)

-- ================================================================
-- LISTENER: MEN√ö
-- ================================================================

task.spawn(function()
	local Events = ReplicatedStorage:FindFirstChild("Events")
	if not Events then return end
	local Bindables = Events:FindFirstChild("Bindables")
	if not Bindables then return end

	local OpenMenuEvent = Bindables:FindFirstChild("OpenMenu")
	if OpenMenuEvent then
		OpenMenuEvent.Event:Connect(function()
			print("üó∫Ô∏è [MinimapIntegrado] Ocultando por apertura de men√∫")
			contenedorMiniMapa.Visible = false
			nivelActualID = nil
			nivelActualIDAnterior = -999
			carpetaPostesReal = nil
		end)
	end
end)

-- ================================================================
-- INIT CHECK
-- ================================================================

task.spawn(function()
	task.wait(2)

	local currentLevel = player:GetAttribute("CurrentLevelID")
	if currentLevel and currentLevel >= 0 then
		print("üó∫Ô∏è [MinimapIntegrado] Detectado nivel pre-existente: " .. currentLevel)
		nivelActualID = currentLevel
		cargarSelectores(currentLevel)
		actualizarCables()
		contenedorMiniMapa.Visible = true
		print("‚úÖ [MinimapIntegrado] Minimapa cargado (init)")
	end
end)

-- ================================================================
-- LOOP DE ACTUALIZACI√ìN
-- ================================================================

local tiempoActualizacionCables = 0

if updateConnection then
	updateConnection:Disconnect()
end

updateConnection = RunService.RenderStepped:Connect(function(dt)
	if not contenedorMiniMapa.Visible then return end

	local char = player.Character
	local root = char and char:FindFirstChild("HumanoidRootPart")
	if not root then return end

	-- Actualizar c√°mara
	local pos = root.Position
	miniCamera.CFrame = CFrame.new(pos.X, pos.Y + ZOOM, pos.Z) * CFrame.Angles(math.rad(-90), 0, 0)

	-- Sincronizar selectores
	sincronizarSelectores()

	-- Actualizar cables
	tiempoActualizacionCables = tiempoActualizacionCables + dt
	if tiempoActualizacionCables >= 0.3 then
		tiempoActualizacionCables = 0
		actualizarCables()
	end
end)

-- ================================================================
-- LIMPIEZA
-- ================================================================

player.AncestryChanged:Connect(function(_, parent)
	if parent == nil then
		if updateConnection then
			updateConnection:Disconnect()
		end
		print("üó∫Ô∏è [MinimapIntegrado] Sistema desactivado")
	end
end)

print("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
print("‚ïë  ‚úÖ MINIMAPA INTEGRADO v1 CARGADO        ‚ïë")
print("‚ïë  Ubicaci√≥n: GUIExplorador.ContenedorMiniMapa")
print("‚ïë  ViewportFrame + WorldModel               ‚ïë")
print("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")